#pragma once

#include <cassert>
#include <experimental/string_view>

#include <iod/metamap/metamap.hh>
#include <iod/metajson/decode_stringstream.hh>

#include <iod/metajson/error.hh>
#include <iod/metajson/symbols.hh>

namespace iod { namespace metajson {

  using namespace ::iod::metamap;
  
  template <typename O>
  inline decltype(auto) wrap_json_output_stream(O&& s)
  {
    return make_metamap(s::append = [&s] (char c) { s << c; });
  }
  
  inline decltype(auto) wrap_json_output_stream(std::stringstream& s)
  {
    return make_metamap(s::append = [&s] (char c) { s << c; });
  }

  inline decltype(auto) wrap_json_output_stream(std::string& s)
  {
    return make_metamap(s::append = [&s] (char c) { s.append(1, c); });
  }

  inline decltype(auto)
  wrap_json_input_stream(std::stringstream& s) { return s; }
  inline decltype(auto)
  wrap_json_input_stream(decode_stringstream& s) { return s; }
  inline decltype(auto)
  wrap_json_input_stream(const std::string& s) { return std::stringstream(s); }
  inline decltype(auto)
  wrap_json_input_stream(const char* s) { return std::stringstream(std::string(s)); }
  inline decltype(auto)
  wrap_json_input_stream(const std::string_view& s) { return std::stringstream(std::string(s)); }

  namespace unicode_impl
  {
    template <typename S, typename T>
    auto json_to_utf8(S&& s, T&& o);

    template <typename S, typename T>
    auto utf8_to_json(S&& s, T&& o);
  }
  
  template <typename I, typename O>
  auto json_to_utf8(I&& i, O&& o)
  {
    return unicode_impl::json_to_utf8(wrap_json_input_stream(std::forward<I>(i)),
                                      wrap_json_output_stream(std::forward<O>(o)));
  }

  template <typename I, typename O>
  auto utf8_to_json(I&& i, O&& o)
  {
    return unicode_impl::utf8_to_json(wrap_json_input_stream(std::forward<I>(i)),
                              wrap_json_output_stream(std::forward<O>(o)));
  }
  
  enum json_encodings
    {
      UTF32BE,
      UTF32LE,
      UTF16BE,
      UTF16LE,
      UTF8
    };

  // Detection of encoding depending on the pattern of the
  // first fourth characters.
  auto detect_encoding(char a, char b, char c, char d)
  {
    // 00 00 00 xx  UTF-32BE
    // xx 00 00 00  UTF-32LE
    // 00 xx 00 xx  UTF-16BE
    // xx 00 xx 00  UTF-16LE
    // xx xx xx xx  UTF-8

    if (a == 0 and b == 0) return UTF32BE;
    else if (c == 0 and d == 0) return UTF32LE;
    else if (a == 0) return UTF16BE;
    else if (b == 0) return UTF16LE;
    else return UTF8;
  }

  // The JSON RFC escapes character codepoints prefixed with a \uXXXX (7-11 bits codepoints)
  // or \uXXXX\uXXXX (20 bits codepoints)

  // uft8 string have 4 kinds of character representation encoding the codepoint of the character.
    
  // 1 byte : 0xxxxxxx  -> 7 bits codepoint ASCII chars from 0x00 to 0x7F
  // 2 bytes: 110xxxxx 10xxxxxx -> 11 bits codepoint
  // 3 bytes: 1110xxxx 10xxxxxx 10xxxxxx -> 11 bits codepoint

  // 1 and 3 bytes representation are escaped as \uXXXX with X a char in the 0-9A-F range. It
  // is possible since the codepoint is less than 16 bits.

  // the 4 bytes representation uses the UTF-16 surrogate pair (high and low surrogate).

  // The high surrogate is in the 0xD800..0xDBFF range (HR) and
  // the low surrogate is in the 0xDC00..0xDFFF range (LR).

  // to encode a given 20bits codepoint c to the surrogate pair.
  //  - substract 0x10000 to c
  //  - separate the result in a high (first 10 bits) and low (last 10bits) surrogate.
  //  - Add 0xD800 to the high surrogate
  //  - Add 0xDC00 to the low surrogate
  //  - the 32 bits code is (high << 16) + low.

  // and to json-escape the high-low(H-L) surrogates representation (16+16bits):
  //  - Check that H and L are respectively in the HR and LR ranges.
  //  - add to H-L 0x0001_0000 - 0xD800_DC00 to get the 20bits codepoint c.
  //  - Encode the codepoint in a string of \uXXXX\uYYYY with X and Y the respective hex digits
  //    of the high and low sequence of 10 bits.
    
  // In addition to utf8, JSON escape characters ( " \ / ) with a backslash and translate
  // \n \r \t \b \r in their matching two characters string, for example '\n' to  '\' followed by 'n'.

  namespace unicode_impl
  {
    template <typename S, typename T>
    auto json_to_utf8(S&& s, T&& o)
    {
      // Convert a JSON string into an UTF-8 string.
      if (s.get() != '"')
        return JSON_KO;//make_json_error("json_to_utf8: JSON strings should start with a double quote.");
      
      while (true)
      {
        // Copy until we find the escaping backslash or the end of the string (double quote).
        while (s.peek() != EOF and s.peek() != '"' and s.peek() != '\\')
          o.append(s.get());

        // If eof found before the end of the string, return an error.
        if (s.eof()) return JSON_KO;// make_json_error("json_to_utf8: Unexpected end of string when parsing a string.");

        // If end of json string, return
        if (s.peek() == '"')
        {
          break;
          return JSON_OK;
        }

        // Get the '\'.
        assert(s.peek() ==  '\\');
        s.get();

        switch (s.get())
        {
          // List of escaped char from http://www.json.org/ 
        default:
          return JSON_KO;//make_json_error("json_to_utf8: Bad JSON escaped character.");
        case '"': o.append('"'); break;
        case '\\': o.append('\\'); break;
        case '/': o.append('/'); break;
        case 'n': o.append('\n'); break;
        case 'r': o.append('\r'); break;
        case 't': o.append('\t'); break;
        case 'b': o.append('\b'); break;
        case 'f': o.append('\f'); break;
        case 'u':
          char a,b,c,d;

          a = s.get();
          b = s.get();
          c = s.get();
          d = s.get();

          if (s.eof())
            return JSON_KO;//make_json_error("json_to_utf8: Unexpected end of string when decoding an utf8 character");

          auto decode_hex_c = [] (char c) {
            if (c >= '0' and c <= '9') return c - '0';
            else return (10 + std::toupper(c) - 'A');
          };
              
          uint16_t x =
            (decode_hex_c(a) << 12) +
            (decode_hex_c(b) << 8) +
            (decode_hex_c(c) << 4) +
            decode_hex_c(d);

          // If x in the  0xD800..0xDBFF range -> decode a surrogate pair \uXXXX\uYYYY -> 20 bits codepoint.
          if (x >= 0xD800 and x <= 0xDBFF)
          {
            if (s.get() != '\\' or s.get() != 'u')
              return JSON_KO;//make_json_error("json_to_utf8: Missing low surrogate.");
          
            uint16_t y =
              (decode_hex_c(s.get()) << 12) +
              (decode_hex_c(s.get()) << 8) +
              (decode_hex_c(s.get()) << 4) +
              decode_hex_c(s.get());

            if (s.eof())
              return JSON_KO;//make_json_error("json_to_utf8: Unexpected end of string when decoding an utf8 character");

            x -= 0xD800;
            y -= 0xDC00;

            int cp = (x << 10) + y + 0x10000;

            o.append(0b11110000 | (cp >> 18));
            o.append(0b10000000 | ((cp & 0x3F000) >> 12));
            o.append(0b10000000 | ((cp & 0x00FC0) >> 6));
            o.append(0b10000000 | (cp & 0x003F));
          
          }
          // else encode the codepoint with the 1-2, or 3 bytes utf8 representation.
          else
          {
            if (x <= 0x007F) // 7bits codepoints, ASCII 0xxxxxxx.
            {
              o.append(uint8_t(x));
            }
            else if (x >= 0x0080 and x <= 0x07FF) // 11bits codepoint -> 110xxxxx 10xxxxxx
            {
              o.append(0b11000000 | (x >> 6));
              o.append(0b10000000 | (x & 0x003F));
            }
            else if (x >= 0x0800 and x <= 0xFFFF) //16bits codepoint -> 1110xxxx 10xxxxxx 10xxxxxx
            {
              o.append(0b11100000 | (x >> 12));
              o.append(0b10000000 | ((x & 0x0FC0) >> 6));
              o.append(0b10000000 | (x & 0x003F));
            }
            else
              return JSON_KO;//make_json_error("json_to_utf8: Bad UTF8 codepoint.");            
          }
          break;
        }
      }

      if (s.get() != '"')
        return JSON_KO;//make_json_error("JSON strings must end with a double quote.");
    
      return JSON_OK;//json_no_error();
    }

    template <typename S, typename T>
    auto utf8_to_json(S&& s, T&& o)
    {
      o.append('"');

      auto encode_16bits = [&] (uint16_t b)
        {
          const char lt[] = "0123456789ABCDEF";
          o.append(lt[b >> 12]);
          o.append(lt[(b & 0x0F00) >> 8]);
          o.append(lt[(b & 0x00F0) >> 4]);
          o.append(lt[b & 0x000F]);
        };

      while (!s.eof())
      {
        // 7-bits codepoint
        while (s.good() and s.peek() <= 0x7F and s.peek() != EOF)
        {
          switch (s.peek())
          {
          case '"': o.append('\\'); o.append('"'); break;
          case '\\': o.append('\\'); o.append('\\'); break;
            //case '/': o.append('/'); break; Do not escape /
          case '\n': o.append('\\'); o.append('n'); break;
          case '\r': o.append('\\'); o.append('r'); break;
          case '\t': o.append('\\'); o.append('t'); break;
          case '\b': o.append('\\'); o.append('b'); break;
          case '\f': o.append('\\'); o.append('f'); break;
          default:
            o.append(s.peek());
          }
          s.get();
        }
      
        if (s.eof()) break;

        // uft8 prefix \u.
        o.append('\\');
        o.append('u');

        uint8_t c1 = s.get();
        uint8_t c2 = s.get();
        {        
          // extract codepoints.
          if (c1 < 0b11100000) // 11bits - 2 char: 110xxxxx	10xxxxxx
          {
            uint16_t cp = ((c1 & 0b00011111) << 6) +
              (c2 & 0b00111111);
            if (cp >= 0x0080 and cp <= 0x07FF)
              encode_16bits(cp);
            else
              return JSON_KO;//make_json_error("utf8_to_json: Bad UTF8 codepoint.");
          }
          else if (c1 < 0b11110000) // 16 bits - 3 char: 1110xxxx	10xxxxxx	10xxxxxx
          {
            uint16_t cp = ((c1 & 0b00001111) << 12) +
              ((c2 & 0b00111111) << 6) +
              (s.get() & 0b00111111);

            if (cp >= 0x0800 and cp <= 0xFFFF)
              encode_16bits(cp);
            else
              return JSON_KO;//make_json_error("utf8_to_json: Bad UTF8 codepoint.");          
          }
          else // 21 bits - 4 chars: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
          {
            int cp =
              ((c1 & 0b00000111) << 18) +
              ((c2 & 0b00111111) << 12) +
              ((s.get() & 0b00111111) << 6) +
              (s.get() & 0b00111111);

            cp -= 0x10000;

            uint16_t H = (cp >> 10) + 0xD800;
            uint16_t L = (cp & 0x03FF) + 0xDC00;

            // check if we are in the right range.
            // The high surrogate is in the 0xD800..0xDBFF range (HR) and
            // the low surrogate is in the 0xDC00..0xDFFF range (LR).
            assert(H >= 0xD800 and H <= 0xDBFF and
                   L >= 0xDC00 and L <= 0xDFFF);

            encode_16bits(H);
            o.append('\\');
            o.append('u');
            encode_16bits(L);
          }
          
        }
      }
      o.append('"');
      return JSON_OK;
    }
  }
}}

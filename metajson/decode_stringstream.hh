#pragma once

#include <string_view>
#include <cmath>

namespace iod { namespace metajson {

  using std::string_view;
  
  namespace internal
  {
    template <typename I>
    void parse_uint(I* val_, const char* str, const char** end)
    {
      I& val = *val_;
      val = 0;
      int i = 0;
      while (i < 40)
      {
        char c = *str;
        if (c < '0' or c > '9') break;
        val = val * 10 + c - '0';
        str++;
        i++;
      }
      if (end)
        *end = str;
    }

    template <typename I>
    void parse_int(I* val, const char* str, const char** end)
    {
      bool neg = false;

      if (str[0] == '-')
      {
        neg = true;
        str++;
      }
      parse_uint(val, str, end);
      if (neg)
        *val = -*val;
    }

    inline unsigned long pow10(unsigned int e)
    {
      unsigned long pows[] = {
        1,
        10,
        100,
        1000,
        10000,
        100000,
        1000000,
        10000000,
        100000000,
        1000000000,
        10000000000,
        100000000000,
        1000000000000,
        10000000000000,
        100000000000000,
        1000000000000000,
        10000000000000000,
        100000000000000000
      };

      if (e < 18)
        return pows[e];
      else
        return 0;
    }
    
    template <typename F>
    void parse_float(F* f, const char* str, const char** end)
    {
      // 1.234e-10
      // [sign][int][decimal_part][exp]

      const char* it = str;
      int integer_part;
      parse_int(&integer_part, it, &it);
      int sign = integer_part >= 0 ? 1 : -1;
      *f = integer_part;
      if (*it == '.')
      {
        it++;
        unsigned long long decimal_part;
        const char* dec_end;
        parse_uint(&decimal_part, it, &dec_end);

        if (dec_end > it)
          *f += (F(decimal_part) / pow10(dec_end - it)) * sign;

        it = dec_end;
      }

      if (*it == 'e' || *it == 'E')
      {
        it++;
        bool neg = false;
        if (*it == '-')
        {
          neg = true;
          it++;
        }

        unsigned int exp = 0;
        parse_uint(&exp, it, &it);
        if (neg)
          *f = *f / pow10(exp);
        else
          *f = *f * pow10(exp);
      }
      
      if (end)
        *end = it;

    }
    
  }

  class decode_stringstream
  {
  public:

    inline decode_stringstream(string_view buffer_)
      : cur(buffer_.data()),
        bad_(false),
        buffer(buffer_) {}
    
    inline bool eof() const { return cur >= &buffer.back(); }
    inline auto& peek() const { return *cur; }
    inline int get()        { return *(cur++); }
    inline int bad() const  { return bad_; }

    template <typename T>
    void operator>>(T& value)
      {
        eat_spaces();
        if constexpr(std::is_floating_point<T>::value) {
            // Decode floating point.
            eat_spaces();
            const char* end = nullptr;
            internal::parse_float(&value, cur, &end);
            if (end == cur)
              bad_ = true;
            cur = end;
          }
        else if constexpr (std::is_integral<T>::value) {
            // Decode integer.
            const char* end = nullptr;
            internal::parse_int(&value, cur, &end);
            if (end == cur)
              bad_ = true;
            cur = end;
          }
        else if constexpr (std::is_same<T, std::string>::value) {
            // Decode UTF8 string.
            json_to_utf8(*this, value);
          }
        else if constexpr (std::is_same<T, string_view>::value) {
            // Decoding to stringview does not decode utf8.

            if (get() != '"')
            {
              bad_ = true;
              return;
            }

            const char* start = cur;
            bool escaped = false;
            
            while (peek() != '\0' and (escaped or peek() != '"'))
            {
              int nb = 0;
              while (peek() == '\\')
                nb++;

              escaped = nb % 2;
              cur++;
            }
            const char* end = cur;
            value = string_view(start, end - start);

            if (get() != '"')
            {
              bad_ = true;
              return;
            }
            
          }
      }

  private:

    inline void eat_spaces()
      {
        while (peek() < 33) ++cur;
      }
    
    int bad_;
    const char* cur;
    string_view buffer; //
  };

}}
